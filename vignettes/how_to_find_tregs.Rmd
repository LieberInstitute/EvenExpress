---
title: "How to Find TREGs"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{How to Find TREGs}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>"
)
```

```{r vignetteSetup, echo=FALSE, message=FALSE, warning = FALSE}
## Track time spent on making the vignette
startTime <- Sys.time()
# Bib setup
library("RefManageR")
## Write bibliography information
bib <- c(
    R = citation(),
    dplyr = ("dplyr"),
    rafalib = citation("rafalib"),
    purrr = citation("purrr"),
    SingleCellExperiment = citation("SingleCellExperiment"),
    SummarizedExperiment = citation("SummarizedExperiment")
)
```


```{r "load_packages"}
library(pheatmap)
library(SingleCellExperiment)
library(dplyr)
library(ggplot2)
library(tidyr)
library(TREG)
```


```{r "download_DLPFC_data"}
# Download and save a local cache of the data avlaible at:
# https://github.com/LieberInstitute/10xPilot_snRNAseq-human#processed-data

bfc <- BiocFileCache::BiocFileCache()
url <- "https://libd-snrnaseq-pilot.s3.us-east-2.amazonaws.com/SCE_DLPFC-n3_tran-etal.rda"
data <- BiocFileCache::bfcrpath(url, x = bfc)

load(data, verbose = TRUE)
```

```{r "Data Size Check", echo=FALSE}
## Using 1/7 GB
# lobstr::obj_size(sce.dlpfc.tran) / 1024^3
```

## Prep Data
Filter and refine data to cell types of interest. We are combining all of the
Excit, Inhib subtypes. 
```{r "define_cell_types"}
## Explore the dimensions and cell type annotations
dim(sce.dlpfc.tran)
table(sce.dlpfc.tran$cellType)

## Use a lower resolution of cell type annotation
sce.dlpfc.tran$cellType.broad <- gsub("_[A-Z]$", "", sce.dlpfc.tran$cellType)
(cell_type_tab <- table(sce.dlpfc.tran$cellType.broad))
```

Drop any groups with < 50 cells.
```{r "drop_small_cell_types"}
## Find cell types with < 50 cells
ct_drop <- names(cell_type_tab)[cell_type_tab < 50]

## Filter columns of sce object
sce.dlpfc.tran <- sce.dlpfc.tran[, !sce.dlpfc.tran$cellType.broad %in% ct_drop]

dim(sce.dlpfc.tran)
```


### Filter Genes
Single Nucleus data is often very sparse (lots of zeros in the count data), this 
dataset is 88% sparse. We can illistrate this in the heat map which is very blue.
```{r, "examine_sparsity"}
## this data is 88% sparse
sum(assays(sce.dlpfc.tran)$counts == 0) / (nrow(sce.dlpfc.tran) * ncol(sce.dlpfc.tran))

## lets make a heatmap of the first 1k genes and 500 cells
count_test <- as.matrix(assays(sce.dlpfc.tran)$counts[1:1000, 1:500])
pheatmap(count_test,
    cluster_rows = FALSE,
    cluster_cols = FALSE,
    show_rownames = FALSE,
    show_colnames = FALSE
)
```

#### Filter to Top 50% Expression
Determine the median expression of genes over all rows, drop all the genes that
are below this limit.
```{r "top50_filter"}
row_means <- rowMeans(assays(sce.dlpfc.tran)$logcounts)
(median_row_means <- median(row_means))

sce.dlpfc.tran <- sce.dlpfc.tran[row_means > median_row_means, ]
dim(sce.dlpfc.tran)
```

After this filter lets check sparsity and make a heatmap of the first 1k genes
and 500 cells. We are seeing more non-blue!
```{r "top50_filter_heatmap"}
## this data down to 77% sparse
sum(assays(sce.dlpfc.tran)$counts == 0) / (nrow(sce.dlpfc.tran) * ncol(sce.dlpfc.tran))

## replot heatmap
count_test <- as.matrix(assays(sce.dlpfc.tran)$counts[1:1000, 1:500])
pheatmap::pheatmap(count_test,
    cluster_rows = FALSE,
    cluster_cols = FALSE,
    show_rownames = FALSE,
    show_colnames = FALSE
)
```

#### Calculate the Proption of Zeros and Pick Cutoff
For each group (let's use `cellType.broad`) get the proportion of zeros for each gene
```{r "get_prop_zero"}
# get prop zero for each gene for each cell type
prop_zeros <- get_prop_zero(sce.dlpfc.tran, group_col = "cellType.broad")
head(prop_zeros)
```

To determine a good cutoff for filtering lets examine the distribution of these
proportions by group.
```{r "prop_zero_distribution"}
# Need to pivot data
prop_zero_long <- prop_zeros %>%
    tibble::rownames_to_column("Gene") %>%
    pivot_longer(!Gene, names_to = "Group", values_to = "prop_zero")

# Plot histograms
(prop_zero_histogram <- ggplot(
    data = prop_zero_long,
    aes(x = prop_zero, fill = Group)
) +
    geom_histogram(binwidth = 0.05) +
    facet_wrap(~Group))
```

Looks like around 0.9 the densities peak, we'll set that as the cutoff.
```{r "pick_cutoff"}
propZero_limit <- 0.9

prop_zero_histogram +
    geom_vline(xintercept = propZero_limit, color = "red", linetype = "dashed")
```

#### Filter by the Max Proption of Zeros
Use the cutoff to filter the remaining genes.  Only  4k or ~11% of genes pass with 
this cutoff. Filter the sce object to this set of genes.
```{r "filter_prop_zero"}
## get a list of filtered genes
filtered_genes <- filter_prop_zero(prop_zeros, cutoff = propZero_limit)
## How many genes pass the filter?
length(filtered_genes)
## What % of genes is this
length(filtered_genes) / nrow(sce.dlpfc.tran)

## Filter the sce object
sce.dlpfc.tran <- sce.dlpfc.tran[filtered_genes, ]
```

One last check of the sparsity and heatmap.

```{r "prop_zero_filter_heatmap"}
## this data down to 50% sparse
sum(assays(sce.dlpfc.tran)$counts == 0) / (nrow(sce.dlpfc.tran) * ncol(sce.dlpfc.tran))

## replot heatmap
count_test <- as.matrix(assays(sce.dlpfc.tran)$counts[1:1000, 1:500])
## Just to help visualization we'll cap the counts at 300
count_test[count_test > 300] <- 300
pheatmap::pheatmap(count_test,
    cluster_rows = FALSE,
    cluster_cols = FALSE,
    show_rownames = FALSE,
    show_colnames = FALSE
)
```

### Run Rank Invariance
```{r "run_RI"}

rowMeans(assays(sce.dlpfc.tran)$logcounts[1:5, 1:5])
```


### Evaluate Canidate Genes
