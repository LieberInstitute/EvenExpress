---
title: "How to Find TREGs"
author: 
  - name: Louise A. Huuki-Myers
    affiliation:
    - &libd Lieber Institute for Brain Development, Johns Hopkins Medical Campus
    email: lahuuki@gmail.com
  - name: Leonardo Collado-Torres
    affiliation:
    - *libd
    email: lcolladotor@gmail.com
date: "`r doc_date()`"
package: "`r pkg_ver('TREG')`"
output: 
  BiocStyle::html_document
vignette: >
  %\VignetteIndexEntry{How to Find TREGs}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>"
)
```

```{r vignetteSetup, echo=FALSE, message=FALSE, warning = FALSE}
## For links
library("BiocStyle")

## Track time spent on making the vignette
startTime <- Sys.time()

# Bib setup
library("RefManageR")

## Write bibliography information
bib <- c(
    R = citation(),
    BiocFileCache = citation("BiocFileCache")[1],
    BiocStyle = citation("BiocStyle")[1],
    dplyr = citation("dplyr")[1],
    ggplot2 = citation("ggplot2")[1],
    knitr = citation("knitr")[1],
    Matrix = citation("Matrix")[1],
    pheatmap = citation("pheatmap")[1],
    purrr = citation("purrr")[1],
    rafalib = citation("rafalib")[1],
    RefManageR = citation("RefManageR")[1],
    rmarkdown = citation("rmarkdown")[1],
    sessioninfo = citation("sessioninfo")[1],
    SummarizedExperiment = citation("SummarizedExperiment")[1],
    testthat = citation("testthat")[1],
    tibble = citation("tibble")[1],
    tidyr = citation("tidyr")[1],
    tran2021 = RefManageR::BibEntry(
        bibtype = "Article",
        key = "tran2021",
        author = "Tran, Matthew N. and Maynard, Kristen R. and Spangler, Abby and Huuki, Louise A. and Montgomery, Kelsey D. and Sadashivaiah, Vijay and Tippani, Madhavi and Barry, Brianna K. and Hancock, Dana B. and Hicks, Stephanie C. and Kleinman, Joel E. and Hyde, Thomas M. and Collado-Torres, Leonardo and Jaffe, Andrew E. and Martinowich, Keri",
        title = "Single-nucleus transcriptome analysis reveals cell-type-specific molecular signatures across reward circuitry in the human brain",
        year = 2021, doi = "10.1016/j.neuron.2021.09.001",
        journal = "Neuron"
    ),
    TREG = citation("TREG")[1],
    TREGpaper = citation("TREG")[2]
)
```

# Basics

## Install `TREG`

`R` is an open-source statistical environment which can be easily modified to enhance its functionality via packages. `r Biocpkg('TREG')` is a `R` package available via Bioconductor. `R` can be installed on any operating system from [CRAN](https://cran.r-project.org/) after which you can install `r Biocpkg('TREG')` by using the following commands in your `R` session:

```{r 'install', eval = FALSE}
if (!requireNamespace("BiocManager", quietly = TRUE)) {
    install.packages("BiocManager")
}

BiocManager::install("TREG")

## Check that you have a valid Bioconductor installation
BiocManager::valid()
```

## Required knowledge

`r Biocpkg('TREG')` `r Citep(bib[['TREG']])` is based on many other packages and in particular in those that have implemented the infrastructure needed for dealing with single cell RNA sequencing data, visualization functions, and interactive data exploration. That is, packages like `r Biocpkg('SummarizedExperiment')` that allow you to store the data.

If you are asking yourself the question "Where do I start using Bioconductor?" you might be interested in [this blog post](http://lcolladotor.github.io/2014/10/16/startbioc/#.VkOKbq6rRuU).

## Asking for help

As package developers, we try to explain clearly how to use our packages and in which order to use the functions. But `R` and `Bioconductor` have a steep learning curve so it is critical to learn where to ask for help. The blog post quoted above mentions some but we would like to highlight the [Bioconductor support site](https://support.bioconductor.org/) as the main resource for getting help regarding Bioconductor. Other alternatives are available such as creating GitHub issues and tweeting. However, please note that if you want to receive help you should adhere to the [posting guidelines](http://www.bioconductor.org/help/support/posting-guide/). It is particularly critical that you provide a small reproducible example and your session information so package developers can track down the source of the error.

## Citing `TREG`

We hope that `r Biocpkg('TREG')` will be useful for your research. Please use the following information to cite the package and the research article describing the data provided by `r Biocpkg('TREG')`. Thank you!

```{r 'citation'}
## Citation info
citation("TREG")
```

# Overview

The `r Biocpkg('TREG')` `r Citep(bib[['TREG']])` package was developed for identifying candidate **Total RNA Expression Genes (TREGs)** for estimating RNA abundance for individual cells in an snFISH experiment by researchers at the Lieber Institute for Brain Development (LIBD) `r Citep(bib[['TREGpaper']])`. 

In this vignette we'll showcase how you can use the R functions provided by `r Biocpkg('TREG')` `r Citep(bib[['TREG']])` with the snRNA-seq dataset that was recently published by our LIBD collaborators `r Citep(bib[['tran2021']])`.

To get started, please load the `r Biocpkg('TREG')` package.

```{r "load_TREG", message = FALSE, warning = FALSE}
library("TREG")
```

# Example TREG use

In this example we will apply our data driven process for TREG discovery to a
snRNA-seq dataset. This process has three main steps:  
1. Data prep   
2. Gene filtering (dropping genes with low expression and high proportion zeros)  
3. Rank Invariance Calculation  

```{r "load_packages"}
library("pheatmap")
library("dplyr")
library("ggplot2")
library("tidyr")
library("tibble")
```

Here we download a public data single nucleus RNA-seq (snRNA-seq) data that 
we'll use as our example `r Citep(bib[['tran2021']])`. It takes 1.01 GB of RAM 
memory to load this object.


```{r "download_DLPFC_data"}
# Download and save a local cache of the data available at:
# https://github.com/LieberInstitute/10xPilot_snRNAseq-human#processed-data
bfc <- BiocFileCache::BiocFileCache()
url <- paste0(
    "https://libd-snrnaseq-pilot.s3.us-east-2.amazonaws.com/",
    "SCE_DLPFC-n3_tran-etal.rda"
)
local_data <- BiocFileCache::bfcrpath(url, x = bfc)

load(local_data, verbose = TRUE)
```

```{r "Data Size Check", echo=FALSE}
## Using 1.01 GB
# lobstr::obj_size(sce.dlpfc.tran) / 1024^3
```

## Prep Data

```{r "acronyms", echo=FALSE}

ct_names <- tibble("Cell Type" = c("Astrocyte", 
                       "Excitatory Neurons", 
                       "Microglia",
                       "Oligodendrocytes",
                       "Oligodendrocyte Progenitor Cells",
                       "Inhibitory Neurons"),
       "Acronym" = c("Astro", "Excit", "Micro", "Oligo", "OPC", "Inhib"))

knitr::kable(ct_names, caption = "Cell Type names and corresponding acromyms used in this dataset")

```

Filter and refine data to cell types of interest. We are combining all of the
Excit, Inhib subtypes.
```{r "define_cell_types"}
## Explore the dimensions and cell type annotations
dim(sce.dlpfc.tran)
table(sce.dlpfc.tran$cellType)

## Use a lower resolution of cell type annotation
sce.dlpfc.tran$cellType.broad <- gsub("_[A-Z]$", "", sce.dlpfc.tran$cellType)
(cell_type_tab <- table(sce.dlpfc.tran$cellType.broad))
```

Drop any groups with < 50 cells.

```{r "drop_small_cell_types"}
## Find cell types with < 50 cells
ct_drop <- names(cell_type_tab)[cell_type_tab < 50]

## Filter columns of sce object
sce.dlpfc.tran <- sce.dlpfc.tran[, !sce.dlpfc.tran$cellType.broad %in% ct_drop]

dim(sce.dlpfc.tran)
```


### Filter Genes

Single Nucleus data is often very sparse (lots of zeros in the count data), this 
dataset is 88% sparse. We can illustrate this in the heat map which is very blue (Figure \@ref(fig:example_sparsity)).

```{r "examine_sparsity", fig.cap = "TODO."}
## this data is 88% sparse
sum(assays(sce.dlpfc.tran)$counts == 0) / (nrow(sce.dlpfc.tran) * ncol(sce.dlpfc.tran))

## lets make a heatmap of the first 1k genes and 500 cells
count_test <- as.matrix(assays(sce.dlpfc.tran)$logcounts[1:1000, 1:500])
pheatmap(count_test,
    cluster_rows = FALSE,
    cluster_cols = FALSE,
    show_rownames = FALSE,
    show_colnames = FALSE
)
```

#### Filter to Top 50% Expression

Determine the median expression of genes over all rows, drop all the genes that
are below this limit.

```{r "top50_filter"}
row_means <- rowMeans(assays(sce.dlpfc.tran)$logcounts)
(median_row_means <- median(row_means))

sce.dlpfc.tran <- sce.dlpfc.tran[row_means > median_row_means, ]
dim(sce.dlpfc.tran)
```

After this filter lets check sparsity and make a heatmap of the first 1k genes
and 500 cells. We are seeing more non-blue (Figure \@ref(fig:top50_filter_heatmap))!

```{r "top50_filter_heatmap", fig.cap = "TODO."}
## this data down to 77% sparse
sum(assays(sce.dlpfc.tran)$counts == 0) / (nrow(sce.dlpfc.tran) * ncol(sce.dlpfc.tran))

## replot heatmap
count_test <- as.matrix(assays(sce.dlpfc.tran)$logcounts[1:1000, 1:500])
pheatmap::pheatmap(count_test,
    cluster_rows = FALSE,
    cluster_cols = FALSE,
    show_rownames = FALSE,
    show_colnames = FALSE
)
```

#### Calculate the Proportion of Zeros and Pick Cutoff

For each group (let's use `cellType.broad`) get the proportion of zeros for each gene

```{r "get_prop_zero"}
# get prop zero for each gene for each cell type
prop_zeros <- get_prop_zero(sce.dlpfc.tran, group_col = "cellType.broad")
head(prop_zeros)
```

To determine a good cutoff for filtering lets examine the distribution of these
proportions by group (Figure \@ref(fig:prop_zero_distribution)).

```{r "prop_zero_distribution", fig.cap = "TODO."}
# Need to pivot data
prop_zero_long <- prop_zeros %>%
    rownames_to_column("Gene") %>%
    pivot_longer(!Gene, names_to = "Group", values_to = "prop_zero")

# Plot histograms
(prop_zero_histogram <- ggplot(
    data = prop_zero_long,
    aes(x = prop_zero, fill = Group)
) +
    geom_histogram(binwidth = 0.05) +
    facet_wrap(~Group))
```

Looks like around 0.9 the densities peak, we'll set that as the cutoff (Figure \@ref(fig:pick_cutoff)).

```{r "pick_cutoff", fig.cap = "TODO."}
## Specify a cutoff, here we use 0.9
propZero_limit <- 0.9

## Add a vertical red dashed line where the cutoff is located
prop_zero_histogram +
    geom_vline(xintercept = propZero_limit, color = "red", linetype = "dashed")
```

#### Filter by the Max Proportion of Zeros

Use the cutoff to filter the remaining genes. Only 4k or ~11% of genes pass with 
this cutoff. Filter the SCE object to this set of genes.

```{r "filter_prop_zero"}
## get a list of filtered genes
filtered_genes <- filter_prop_zero(prop_zeros, cutoff = propZero_limit)

## How many genes pass the filter?
length(filtered_genes)

## What % of genes is this
length(filtered_genes) / nrow(sce.dlpfc.tran)

## Filter the sce object
sce.dlpfc.tran <- sce.dlpfc.tran[filtered_genes, ]
```

One last check of the sparsity and heatmap (Figure \@ref(fig:prop_zero_filter_heatmap)).

```{r "prop_zero_filter_heatmap", fig.cap = "TODO."}
## this data down to 50% sparse
sum(assays(sce.dlpfc.tran)$counts == 0) / (nrow(sce.dlpfc.tran) * ncol(sce.dlpfc.tran))

## re-plot heatmap
count_test <- as.matrix(assays(sce.dlpfc.tran)$logcounts[1:1000, 1:500])
## Just to help visualization we'll cap the counts at 300
count_test[count_test > 300] <- 300
pheatmap::pheatmap(count_test,
    cluster_rows = FALSE,
    cluster_cols = FALSE,
    show_rownames = FALSE,
    show_colnames = FALSE
)
```

### Run Rank Invariance

To get the Rank Invariance (RI), the rank of the genes across the cells in a group,
and between groups is considered. One way to calculate RI is to dine (TODO: dine??) the group 
rank values, and cell rank values separately, then combine them as shown below.
The genes with the top RI values are the best candidate TREGs.

```{r "rank_invariance_stepwise"}
## Get the rank of the gene in each group
group_rank <- rank_group(sce.dlpfc.tran, group_col = "cellType.broad")

## Get the rank of the gene for each cell
cell_rank <- rank_cells(sce.dlpfc.tran, group_col = "cellType.broad")

## Use both rankings to calculate rank_invariance()
rank_invar <- rank_invariance(group_rank, cell_rank)
head(rank_invar[sort.list(rank_invar, decreasing = TRUE)])
```

The `rank_invariance_express()` function combines these three steps into one
function, and achieves the same results. 

```{r "run_RI_express"}
## rank_invariance_express() runs the previous functions for you
rank_invar2 <- rank_invariance_express(
    sce.dlpfc.tran,
    group_col = "cellType.broad"
)
head(rank_invar2[sort.list(rank_invar2, decreasing = TRUE)])

## Check computationally that the results are identical
stopifnot(identical(rank_invar, rank_invar2))
```

# Conclusion

TODO: mention how we validated some TREGs in the paper `r Citep(bib[['TREGpaper']])`, how you might want to consider generating this data in your experiments, and how TREGs might be useful for future deconvolution algorithms.


# Reproducibility

The `r Biocpkg('TREG')` package `r Citep(bib[['TREG']])` was made possible thanks to:

* R `r Citep(bib[['R']])`
* `r Biocpkg('BiocFileCache')` `r Citep(bib[['BiocFileCache']])`
* `r Biocpkg('BiocStyle')` `r Citep(bib[['BiocStyle']])`
* `r CRANpkg('dplyr')` `r Citep(bib[['dplyr']])`
* `r CRANpkg('ggplot2')` `r Citep(bib[['ggplot2']])`
* `r CRANpkg('knitr')` `r Citep(bib[['knitr']])`
* `r CRANpkg('Matrix')` `r Citep(bib[['Matrix']])`
* `r CRANpkg('pheatmap')` `r Citep(bib[['pheatmap']])`
* `r CRANpkg('purrr')` `r Citep(bib[['purrr']])`
* `r CRANpkg('rafalib')` `r Citep(bib[['rafalib']])`
* `r CRANpkg("RefManageR")` `r Citep(bib[["RefManageR"]])`
* `r CRANpkg('rmarkdown')` `r Citep(bib[['rmarkdown']])`
* `r CRANpkg('sessioninfo')` `r Citep(bib[['sessioninfo']])`
* `r Biocpkg('SummarizedExperiment')` `r Citep(bib[['SummarizedExperiment']])`
* `r CRANpkg('testthat')` `r Citep(bib[['testthat']])`
* `r CRANpkg('tibble')` `r Citep(bib[['tibble']])`
* `r CRANpkg('tidyr')` `r Citep(bib[['tidyr']])`


Code for creating the vignette

```{r createVignette, eval=FALSE}
## Create the vignette
library("rmarkdown")
system.time(render("TREG.Rmd"))

## Extract the R code
library("knitr")
knit("TREG.Rmd", tangle = TRUE)
```


Date the vignette was generated.

```{r reproduce1, echo=FALSE}
## Date the vignette was generated
Sys.time()
```

Wallclock time spent generating the vignette.

```{r reproduce2, echo=FALSE}
## Processing time in seconds
totalTime <- diff(c(startTime, Sys.time()))
round(totalTime, digits = 3)
```

`R` session information.

```{r reproduce3, echo=FALSE}
## Session info
library("sessioninfo")
options(width = 120)
session_info()
```

# Bibliography

This vignette was generated using `r Biocpkg('BiocStyle')` `r Citep(bib[['BiocStyle']])`, `r CRANpkg('knitr')` `r Citep(bib[['knitr']])` and `r CRANpkg('rmarkdown')` `r Citep(bib[['rmarkdown']])` running behind the scenes.

Citations made with `r CRANpkg('RefManageR')` `r Citep(bib[['RefManageR']])`.

```{r vignetteBiblio, results = 'asis', echo = FALSE, warning = FALSE, message = FALSE}
## Print bibliography
PrintBibliography(bib, .opts = list(hyperlink = "to.doc", style = "html"))
```

